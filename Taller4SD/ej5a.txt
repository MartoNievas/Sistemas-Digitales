.text
.global main
.global Factorial

main:
    #Test 1
    li a0, 4              # calcular factorial 4
    jal ra, Factorial     # guardo ra y llamo la funcion factorial

    li t0, 24             # 4! = 24
    bne a0, t0, noFunciona
    
    #Test 2
    li a0, 0             # calcular factorial de caso base
    jal ra, Factorial     # guardo ra y llamo la funcion factorial

    li t0, 1            # 0! = 1
    bne a0, t0, noFunciona

funciona:
    li a1, 1              # ok funcionan
    j fin

noFunciona:
    li a1, 0              # no funcionan 
    j fin

fin:
    j fin                # Bucle infinito para terminar

Factorial:
    addi sp, sp, -16      # Prólogo: reservar 16 bytes de stack
    sw a0, 4(sp)          # guardar parametro n en a0
    sw ra, 0(sp)          # Guardamos dirección de retorno

    li t0, 1              # t0 = 1
    bgt a0, t0, else_case # Si n > 1, ir al caso recursivo

   # Caso base: factorial(0) o factorial(1) = 1
    li a0, 1
    addi sp, sp, 16       # Liberamos stack
    jr ra                 # Volvemos al llamador

else_case:
    addi a0, a0, -1       # a0 = a0 - 1
    jal ra, Factorial     # Llamada recursiva: factorial(n - 1)

    lw t1, 4(sp)          # Recuperar n original desde stack
    lw ra, 0(sp)          # Recuperar ra
    addi sp, sp, 16       # Liberar stack

    mul a0, t1, a0        # res =  n * factorial(n - 1)
    jr ra                 # Volver al llamador
